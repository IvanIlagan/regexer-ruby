# Getting Started
- [Terminologies](#terminologies)
- [Building patterns](#building-patterns)
  - [Layout](#layout)
  - [Adding Patterns](#adding-patterns)
  - [Using The Final Pattern](#using-the-final-pattern)
- [Patterns](#patterns)
  - [Standalone Patterns](#standalone-patterns)
    - [Letter In a Given Range](#letter-in-a-given-range)
    - [Number In a Given Range](#number-in-a-given-range)
    - [ASCII Character In a Given Range](#ascii-character-in-a-given-range)
    - [Any Character In a Given Set of Characters](#any-character-in-a-given-set-of-characters)
    - [Any Character Not In a Given Set of Characters](#any-character-not-in-a-given-set-of-characters)
    - [Or](#or)
    - [Word Character](#word-character)
    - [Non-word Character](#non-word-character)
    - [Whitespace Character](#whitespace-character)
    - [Non-whitespace Character](#non-whitespace-character)
    - [Digit Character](#digit-character)
    - [Non-digit Character](#non-digit-character)
    - [Newline Character](#newline-character)
    - [Tab Character](#tab-character)
    - [Alphanumeric Character](#alphanumeric-character)
    - [Any Character Except Line Break](#any-character-except-line-break)
    - [Carriage Return Character](#carriage-return-character)
    - [Vertical Tab Character](#vertical-tab-character)
  - [Chainable Patterns](#chainable-patterns)
    - [Contains Set of Characters](#contains-set-of-characters)
    - [Starts With a Group of Characters](#starts-with-a-group-of-characters)
    - [Ends With a Group of Characters](#ends-with-a-group-of-characters)
    - [Consecutive Group of Characters](#consecutive-group-of-characters)
    - [None or Consecutive Group of Characters](#none-or-consecutive-group-of-characters)
    - [None or One Instance of Character](#none-or-one-instance-of-character)
    - [Group of Characters or Patterns](#group-of-characters-or-patterns)
    - [Containing Words](#containing-words)
      - [Contains The Word](#contains-the-word)
      - [Contains a Word Starting With](#contains-a-word-starting-with)
      - [Contains a Word Ending With](#contains-a-word-ending-with)
- [Value Builder Methods](#value-builder-methods)

## Terminologies
- Pattern Object

    This is the base object for all patterns generated by the PatternBuilder. Essentially, all
    methods called within the PatternBuilder class all returns this object.

- Standalone Patterns

    These are pattern methods that have no parameters or if given a parameter, they don't accept Regexer::Models::Pattern objects but accepts a strict set of values OR required set of keyword arguments. These methods can be used on their own OR as values for other methods to make a chain.

- Chainable Patterns

    These are pattern methods that not only accepts strict set of data types but it also accepts a Regexer::Models::Pattern objects as parameters. What makes these methods chainable is that all of the methods used here all return a Regexer::Models::Pattern object. Given that, we can call another pattern method to be used as the paramater instead of the other data types for added expressiveness.

- Value Builder Methods

    These are methods that helps in building values that are compatible to be accepted as parameters of the pattern methods.

- Single Entity Value

    These are values that are identified by regexer as a single entity. For a value to be identified
    as a single entity, the value should be a single character or a single digit integer or a 
    Regexer::Models::Pattern object with single_entity value of true. The purpose for this is that
    when building patterns, regexer will wrap non-single entity values with parenthesis else
    it justs builds the given value as is in the final built pattern.

## Building Patterns
## Layout
When building your regex patterns with regexer, always instantiate the Regexer::PatternBuilder class and give it a block
```ruby
Regexer::PatternBuilder.new do
  # patterns here
end
```

## Adding Patterns
To start adding your patterns, just call the available [pattern methods](#patterns) and supply them values based on your needs.

Highly recommend to add your patterns line by line. This is because the pattern builder builds the pattern from left to right.

```ruby
Regexer::PatternBuilder.new do
  starts_with "Hi!"             # builds "^(Hi!)"
  has_letter from: "A", to: "z" # builds "[A-z]"
  has_number from: 0, to: 9     # builds "[0-9]"
  ends_with "Bye"               # builds "(Bye)$"
end

# Based on the above pattern, it will have this as the final built pattern: "^(Hi!)[A-z][0-9](Bye)$"
```

In addition, you can chain the pattern methods together to build a much more customized human readable pattern. Mix and match the pattern methods based on your needs and expressiveness.
```ruby
Regexer::PatternBuilder.new do
  starts_with consecutive_instances_of letter from: "A", to: "z" # builds "^([A-z]+)"
  contains number from: 0, to: 9                                 # builds "[0-9]"
end

# Based on the above pattern, it will have this as the final built pattern: "^([A-z]+)[0-9]"
```

So far, very few methods allow that kind of chain. See [here](#chainable-patterns) for the full list of chainable pattern methods

## Using The Final Pattern
Once you finished building your pattern, you need to call the result method of the PatternBuilder class to get the final built pattern from the pattern builder.

The result method will return a Regexer::Models::Pattern object. The object has the following methods:
- raw_pattern
- regex

The raw_pattern method returns the final built pattern as a string while the regex method returns the final built pattern as a Regexp object.
```ruby
pattern_builder_result = Regexer::PatternBuilder.new do
  starts_with "Hi!"             # builds "^(Hi!)"
  has_letter from: "A", to: "z" # builds "[A-z]"
  has_number from: 0, to: 9     # builds "[0-9]"
  ends_with "Bye"               # builds "(Bye)$"
end.result

puts pattern_builder_result.raw_pattern
# outputs "^(Hi!)[A-z][0-9](Bye)$"
puts "Hello".match?(pattern_builder_result.regex)
# outputs /^(Hi!)[A-z][0-9](Bye)$/
```

Take note that the PatternBuilder#result returns a non-single entity Regexer::Models::Pattern object

## Patterns
## Standalone Patterns
### Letter In a Given Range
In regex, we mostly do this pattern in matching a text if it contains a letter within a certain range: /[A-z]/

In regexer, its equivalent is the has_letter or letter method
```ruby
Regexer::PatternBuilder.new do
  has_letter from: "A", to: "z" # builds "[A-z]"
  letter from: "A", to: "z"     # builds "[A-z]"
end
```

The method requires 2 keyword arguments named from and to in which we can only assign a string value to each of them.

In line with the method name, the arguments strictly accepts only 1 character string that is any letter in the english alphabet. Also the value for the from argument should always be lower than the to argument value in terms of ascii value. If an invalid value is given, an exception is raised.

This method returns a single entity Regexer::Models::Pattern object

### Number In a Given Range
In regex, we mostly do this pattern in matching a text if it contains a number within a certain range: /[0-9]/

In regexer, its equivalent is the has_number or number method
```ruby
Regexer::PatternBuilder.new do
  has_number from: 0, to: 9 # builds "[0-9]"
  number from: 0, to: 9     # builds "[0-9]"
end
```

The method requires 2 keyword arguments named from and to in which we can only assign a positive integer value to each of them. Also the value for the from argument should always be lower than the to argument value. If an invalid value is given, an exception is raised.

This method returns a single entity Regexer::Models::Pattern object

### ASCII Character In a Given Range
To extend the power of the range in regex, the has_ascii_character or ascii_character method allows us to produce a pattern to check for characters within a range of the given ascii character.

```ruby
Regexer::PatternBuilder.new do
  has_ascii_character from: "<", to: "}" # builds "[<-\\}]"
  ascii_character from: "0", to: "9"     # builds "[0-9]"
end
```

The method requires 2 keyword arguments named from and to in which we can only assign a single character string that is in the ASCII table. The value for the from argument should always be lower than the to argument value. If an invalid value is given, an exception is raised.

Keep in mind that there are characters in the ASCII table that has a special function in regex. So given that, this method automatically escapes those characters.

This method returns a single entity Regexer::Models::Pattern object

### Any Character In a Given Set of Characters
As the name suggests, we can build patterns to match any character in a given set using the has_any_character_in or any_character_in method. This method leverages the square bracket pairs in which it functions the same thing in regex.

```ruby
Regexer::PatternBuilder.new do
  has_any_character_in "aeiou" # builds "[aeiou]"
  any_character_in 2468        # builds "[2468]
end
```

The method accepts String, Integer, Float and Hash data types as its argument. Do take note that when we give the method a hash, it only accepts that hash IF it contains the 'from' and 'to' keys in that specific order. If any other data types or a hash with any other key names are given, an exception is raised. It will also raise an exception if it fails the value validation also, which is quite similar with the value validation of the has_ascii_character method.

To lessen the burden of passing a manually made Hash and to add more readability, we can use the value builder method [character_range](#character-range) to create a CharacterRangePattern object. That object
is has attributes named from & to and their values are always compatible with this method.

The method is not restricted to accept 1 parameter. It can actually take as many parameter as you want as to maximize the usage of the square brackets.

```ruby
# Multi params usage
Regexer::PatternBuilder.new do
  # Alphanumeric only character regex pattern sample
  has_any_character_in character_range(from: 'A', to: 'Z'),
                       character_range(from:'a', to: 'z'),
                       character_range(from: '0', to: '9')       # builds [A-Za-z0-9]

  has_any_character_in "dog",
                        character_range(from: "!", to: "/"),
                        12_345                                   # builds [dog!-/12345]
end
```

This method returns a single entity Regexer::Models::Pattern object

### Any Character Not In a Given Set of Characters
This is the inverse of the has_any_character_in method of regexer. This just adds the unescaped '^' character as the first entry in the square brackets to denote in regex that any character in the square brackets should not exist in the string being matched. We can use this functionality by calling the has_any_character_not_in or any_character_not_in method.

```ruby
# Single params usage
Regexer::PatternBuilder.new do
  has_any_character_not_in "aeiou" # builds "[^aeiou]"
  any_character_not_in 2468        # builds "[^2468]
end

# Multi params usage
Regexer::PatternBuilder.new do
  # Alphanumeric only character regex pattern sample
  has_any_character_not_in character_range(from: 'A', to: 'Z'),
                           character_range(from: 'a', to: 'z'),
                           character_range(from: '0', to: '9')      # builds [^A-Za-z0-9]

  has_any_character_not_in "dog",
                           character_range(from: "!", to: "/"),
                           12_345                                   # builds [^dog!-/12345]
end
```

The method functions the same as with the has_any_character_in method like they have the same argument data types, argument values and validations.

This method returns a single entity Regexer::Models::Pattern object

### Or
In regex, the special character '|' serves as matching a pattern matching either character before or after it. This exact character is represented by the \_or_ method.

```ruby
Regexer::PatternBuilder.new do
  _or_  # builds |

  # Building 1|2 pattern
  # Multi-line
  contains 1
  _or_
  contains 2

  # Single line
  contains 1; _or_; contains 2
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Word Character
In regex, there is a special shorthand character that matches any alphanumeric character and underscore and that is the \w or Word pattern. Regexer also offers that exact pattern via the has_word_character or word_character method. This method is equivalent to [A-Za-z0-9_] regex pattern
```ruby
Regexer::PatternBuilder.new do
  has_word_character # builds "\\w"
  word_character     # builds "\\w"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Non-word Character
In regex, there is a special shorthand character that matches any character other than alphanumeric character and underscore and that is the \W or Non-word pattern. Regexer also offers that exact pattern via the has_non_word_character or non_word_character method. This method is equivalent to [^A-Za-z0-9_] regex pattern
```ruby
Regexer::PatternBuilder.new do
  has_non_word_character # builds "\\W"
  non_word_character     # builds "\\W"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Whitespace Character
In regex, there is a special shorthand character that matches any whitespace characters like spaces, newline, tab etc.... and that is the \s or Whitespace pattern. Regexer also offers that exact pattern via the has_whitespace_character or whitespace_character method.
```ruby
Regexer::PatternBuilder.new do
  has_whitespace_character # builds "\\s"
  whitespace_character     # builds "\\s"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Non Whitespace Character
In regex, there is a special shorthand character that matches any character that is not a whitespace and that is the \S or Non-whitespace pattern. Regexer also offers that exact pattern via the has_non_whitespace_character or non_whitespace_character method.
```ruby
Regexer::PatternBuilder.new do
  has_non_whitespace_character # builds "\\S"
  non_whitespace_character     # builds "\\S"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Digit Character
In regex, there is a special shorthand character that matches any number character from 0 to 9 and that is the \d or Digit pattern. Regexer also offers that exact pattern via the has_digit_character or digit_character method.
```ruby
Regexer::PatternBuilder.new do
  has_digit_character # builds "\\d"
  digit_character     # builds "\\d"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Non Digit Character
In regex, there is a special shorthand character that matches any character that is not a number from 0-9 and that is the \D or Non-digit pattern. Regexer also offers that exact pattern via the has_non_digit_character or non_digit_character method.
```ruby
Regexer::PatternBuilder.new do
  has_non_digit_character # builds "\\D"
  non_digit_character     # builds "\\D"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Newline Character
In regex, there is a special shorthand character that matches a newline character and that is the \n or newline pattern. Regexer also offers that exact pattern via the has_newline_character or newline_character method.
```ruby
Regexer::PatternBuilder.new do
  has_newline_character # builds "\\n"
  newline_character     # builds "\\n"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Tab Character
In regex, there is a special shorthand character that matches a tab character and that is the \t or tab pattern. Regexer also offers that exact pattern via the has_tab_character or tab_character method.
```ruby
Regexer::PatternBuilder.new do
  has_tab_character # builds "\\t"
  tab_character     # builds "\\t"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Alphanumeric Character
This is a method in which it builds the respective regex pattern for you in matching a text containing any alphanumeric pattern.
```ruby
Regexer::PatternBuilder.new do
  has_alphanumeric_character # builds "[A-Za-z0-9]"
  alphanumeric_character     # builds "[A-Za-z0-9]"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Any Character Except Line Break
In regex, there is a special character that matches any number character except line breaks and that is the . or Dot pattern. Regexer also offers that exact pattern via the has_any_character_except_new_line or any_character_except_new_line method.
```ruby
Regexer::PatternBuilder.new do
  has_any_character_except_new_line # builds "."
  any_character_except_new_line     # builds "."
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Carriage Return Character
In regex, there is a special shorthand character that matches a carriage return character and that is the \r or carriage return pattern. Regexer also offers that exact pattern via the has_carriage_return_character or carriage_return_character method.
```ruby
Regexer::PatternBuilder.new do
  has_carriage_return_character # builds "\\r"
  carriage_return_character     # builds "\\r"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

### Vertical Tab Character
In regex, there is a special shorthand character that matches a vertical tab character and that is the \v or vertical tab pattern. Regexer also offers that exact pattern via the has_vertical_tab_character or vertical_tab_character method.
```ruby
Regexer::PatternBuilder.new do
  has_vertical_tab_character # builds "\\r"
  vertical_tab_character     # builds "\\r"
end
```

The method does not accept any arguments. We can freely call it as is in the pattern builder.

This method returns a single entity Regexer::Models::Pattern object

## Chainable patterns
### Contains Set of Characters
This is a method in which it acts like directly adding the set of characters into the regex
```ruby
Regexer::PatternBuilder.new do
  contains "t"          # builds "t"
  contains 1234         # builds "(1234)"
  contains 5.43         # builds "(5\\.43)"
  contains "+-/hey__$^" # builds "(\\+\\-/hey__\\$\\^)"
  contains 2            # builds "2"
end
```

The method accepts one argument in which it can be a string, integer, float and even the Regexer::Models::Pattern object. If an invalid value is given, an exeption is raised

Keep in mind that when using this method, it escapes characters that has a special function in regex and
when given a non-single entity value, it wraps the value in parentheses.

This method returns a single entity Regexer::Models::Pattern object
### Starts With a Group of Characters
Just like in regex, regexer offers a method called starts_with that allows us to generate a pattern for finding groups of characters or substrings at the beginning of text
```ruby
Regexer::PatternBuilder.new do
  starts_with "t"          # builds "^t"
  starts_with 1234         # builds "^(1234)"
  starts_with 5.43         # builds "^(5\\.43)"
  starts_with "+-/hey__$^" # builds "^(\\+\\-/hey__\\$\\^)"
end
```

The method behaves exactly the same with the contains method, the only difference is that it adds the "^" character at the beginning of the given value

This method returns a non-single entity Regexer::Models::Pattern object

### Ends With a Group of Characters
Just like in regex, regexer offers a method called ends_with that allows us to generate a pattern for finding groups of characters at the end of text
```ruby
Regexer::PatternBuilder.new do
  ends_with "t"          # builds "t$"
  ends_with 1234         # builds "(1234)$"
  ends_with 5.43         # builds "(5\\.43)$"
  ends_with "+-/hey__$^" # builds "(\\+\\-/hey__\\$\\^)$"
end
```

The method behaves exactly the same with the contains method, the only difference is that it adds the "$" character at the end of the given value

This method returns a non-single entity Regexer::Models::Pattern object

### Consecutive Group of Characters
In regex, we have the special character '+' that allows us to match a text that has consecutive repeating character or group of characters. We can use that special character by calling the has_consecutive_instances_of or consecutive_instances_of method

```ruby
Regexer::PatternBuilder.new do
  has_consecutive_instances_of "t"      # builds "t+"
  has_consecutive_instances_of 1234     # builds "(1234)+"
  consecutive_instances_of 5.43         # builds "(5\\.43)+"
  consecutive_instances_of "+-/hey__$^" # builds "(\\+\\-/hey__\\$\\^)+"
end
```

It also functions the same as the contains method since it is being used by it behind the scenes to build the pattern and then the method itself just appends the '+' character at the end of it.

Additionally, this method has multiple available options aside from the default which is matching consecutive repeating character or group of characters. The options are:

- exactly
- minimum
- maximum

All options will only accept integer as values. Otherwise, it will raise an error.

Do keep in mind that when an option is specified, it follows a prioritization for generating the
appropriate quantifier. The priority is as follows: exactly, minimum, maximum.

For the exactly option, when given a number, the method will not use the '+' for building the regex pattern but instead it will use '{n}' so that the regex pattern will only
match if the text has exactly the N number of consecutive instances of given character or group of characters.

```ruby
Regexer::PatternBuilder.new do
  has_consecutive_instances_of "t", exactly: 4       # builds "t{4}"
  has_consecutive_instances_of 1234, exactly: 2      # builds "(1234){2}"
  consecutive_instances_of 5.43, exactly: 1          # builds "(5\\.43){1}"
  consecutive_instances_of "+-/hey__$^", exactly: 10 # builds "(\\+\\-/hey__\\$\\^){10}"
end
```

For the minimum option, when given a number, the method will not use the '+' for building the regex pattern but instead it will use '{n,}' so that the regex pattern will only
match if the text has the minimum N number of consecutive instances or more of given character or group of characters.

```ruby
Regexer::PatternBuilder.new do
  has_consecutive_instances_of "t", minimum: 4       # builds "t{4,}"
  has_consecutive_instances_of 1234, minimum: 2      # builds "(1234){2,}"
  consecutive_instances_of 5.43, minimum: 1          # builds "(5\\.43){1,}"
  consecutive_instances_of "+-/hey__$^", minimum: 10 # builds "(\\+\\-/hey__\\$\\^){10,}"
end
```

For the maximum option, this will require the minimum option to also be specified. If the minimum option is not specified, it will raise an error. When the required options are specified, the method will not use the '+' for building the regex pattern but instead it will use '{minN,maxN}' so that the regex pattern will only
match if the text has the minimum N number & maximum N number of consecutive instances of given character or group of characters.

Do take note that the minimum value should always be lower than the maximum value, else it will raise an error.

```ruby
Regexer::PatternBuilder.new do
  has_consecutive_instances_of "t", minimum: 4, maximum: 7           # builds "t{4,7}"
  has_consecutive_instances_of 1234, minimum: 2, maximum: 3          # builds "(1234){2,3}"
  consecutive_instances_of 5.43, minimum: 1, maximum: 23             # builds "(5\\.43){1,23}"
  consecutive_instances_of "+-/hey__$^", minimum: 10, maximum: 1500  # builds "(\\+\\-/hey__\\$\\^){10,1500}"
end
```

This method returns a non-single entity Regexer::Models::Pattern object

### None or Consecutive Group of Characters
In regex, we have the special character '*' that allows us to match a text that has none or consecutive repeating character or group of characters. We can use that special character by calling the has_none_or_consecutive_instances_of or none_or_consecutive_instances_of method

```ruby
Regexer::PatternBuilder.new do
  has_none_or_consecutive_instances_of "t"      # builds "t*"
  has_none_or_consecutive_instances_of 1234     # builds "(1234)*"
  none_or_consecutive_instances_of 5.43         # builds "(5\\.43)*"
  none_or_consecutive_instances_of "+-/hey__$^" # builds "(\\+\\-/hey__\\$\\^)*"
end
```

It also functions the same as the contains method since it is being used by it behind the scenes to build the pattern and then the method itself just appends the '*' character at the end of it.

### None or One Instance of Character
In regex, we have the special character '?' that allows us to match a text that has none or one instance of character or group of characters. We can use that special character by calling the has_none_or_one_instance_of or none_or_one_instance_of method

```ruby
Regexer::PatternBuilder.new do
  has_none_or_one_instance_of "t"      # builds "t?"
  has_none_or_one_instance_of 1234     # builds "(1234)?"
  none_or_one_instance_of 5.43         # builds "(5\\.43)?"
  none_or_one_instance_of "+-/hey__$^" # builds "(\\+\\-/hey__\\$\\^)?"
end
```

It also functions the same as the contains method since it is being used by it behind the scenes to build the pattern and then the method itself just appends the '?' character at the end of it.

### Group of Characters or Patterns
Just like in regex, regexer offers a method called has_group or group that allows us to generate a pattern for finding groups of characters or substrings via the parentheses in regex.
```ruby
Regexer::PatternBuilder.new do
  has_group do
    has_letter from: "A", to: "z"
    contains "@"
    ends_with consecutive_instances_of number from: 0, to: 9
  end # builds "([A-z]@([0-9]+)$)"
end
```

The method only accepts a block and that block acts similar to the PatternBuilder class in which
we can build another set of pattern just within that certain context. Same errors will be raised
when invalid values are given to the methods called within that block

This method returns a single entity Regexer::Models::Pattern object

### Containing Words
In regex there is a shorthand character that is zero-length and sets a boundary to be used as the starting point to check for matches in a word. This shorthand is in the form of '\b' which is called a word boundary. 

The definition of a word boundary, in terms of positioning, is a place in between a word character and a non-word character or the start/end of a string. With the '\b' denoting the boundary, the following shows where the word boundary lies: "\bhi\b" or " \bhello\b" or "\bhey\b " or "\bmorning\b!". If we look at the examples again, the boundary positions is really similar to the places that we always look for when forming words.

In the context of regexer, we use that common identifier in the usage of the word boundary shorthand. Hence regexer offers multiple methods which are conveniently named: **contains_the_word**, **contains_a_word_starting_with** and **contains_a_word_ending_with**. These are made into 3 separate methods so that it can be used flexibly and still structured into an english-like sentence.


<h4 id="contains-the-word">contains_the_word</h4>

This basically does is the same with the contains method but also wraps the value with '\b' characters. As the name suggests, this is used to match a word exactly as given.
```ruby
Regexer::PatternBuilder.new do
  contains_the_word "hi"              # builds "\b(hi)\b"

  # aliases
  the_word "everyone"               # builds "\b(everyone)\b"
  contains_a_word_with "hello"      # builds "\b(hello)\b"
  a_word_with "everybody"           # builds "\b(everybody)\b"
end
```

This method contains a lot more aliases then other methods. This is because the scenarios that the '\b' placed around a value are a lot. Example is you can use it to find exact words and another is you can use it to find words that satisfies a condition like words with exactly 5 letters or words with no vowels. Given that, the aliases allows us to construct a more fitting and easily understood english sentence based on our use cases. The methods #contains_the_word and #the_word fits the scenario where you want to find specific words while the #contains_a_word_with and #a_word_with fits the scenario where you want to find a word based on a condition.

<h4 id="contains-a-word-starting-with">contains_a_word_starting_with</h4>

Same as with the other word bounded methods, this also uses the contains method but this time it only puts the '\b' character at the beginning of the value. You can use this when finding words starting with a character/set of characters.
```ruby
Regexer::PatternBuilder.new do
  contains_a_word_starting_with "hi"              # builds "\b(hi)"

  # aliases
  a_word_starting_with "everybody"                # builds "\b(everybody)"
end
```

<h4 id="contains-a-word-ending-with">contains_a_word_ending_with</h4>

Same as with the other word bounded methods, this also uses the contains method but this time it only puts the '\b' character at the end of the value. You can use this when finding words ending with a character/set of characters.
```ruby
Regexer::PatternBuilder.new do
  contains_a_word_ending_with "hi"              # builds "(hi)\b"

  # aliases
  a_word_ending_with "everybody"                # builds "(everybody)\b"
end
```

**NOTE:** Keep in mind the definition of the word boundary when using the above methods. You may experience weird regex matches but in reality, it is supposed to work that way as specified in the definition. Example, if you put a non-word character before or after the '\b' character e.g. "hi!\b". You may think that it would match the 'hi!' in the string "hi! hello" but unfortunately not. Since '\b' is in between of 2 non-word characters which is '!' and a space. For that regex to match, the string should be "hi!hello" since it satisfies the definition in which '\b' is in between a word character (which is 'h') and a non-word character (which is '!').

This method returns a non-single entity Regexer::Models::Pattern object

## Value Builder Methods
### Character Range
A method that builds a CharacterRangePattern object with the attributes named from & to.

This method will always return that object and any value given to it, those values will always be regex escaped.

Do take note that this method runs value validations which is similar with the has_ascii_character method. If it didn't pass the value validation, this will raise an exception.

Also, this method is only available within the context of the Regexer::PatternBuilder

Usage
```ruby
Regexer::PatternBuilder.new do
  character_range from: 'a', to: 'z'
  has_any_character_in character_range from: 'a', to: 'z'
end
```

